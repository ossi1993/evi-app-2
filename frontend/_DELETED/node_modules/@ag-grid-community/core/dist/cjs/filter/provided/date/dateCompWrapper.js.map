{"version":3,"sources":["../../src/ts/filter/provided/date/dateCompWrapper.ts"],"names":[],"mappings":";;;;;;;;AAOA;+FAC+F;AAC/F;IAOI,yBAAY,OAAgB,EAAE,oBAA0C,EAAE,mBAAgC,EAAE,OAAoB;QAAhI,iBAqBC;QAxBO,UAAK,GAAG,IAAI,CAAC;QAIjB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QAEvB,oBAAoB,CAAC,gBAAgB,CAAC,mBAAmB,CAAC,CAAC,IAAI,CAAC,UAAA,QAAQ;YACpE,0EAA0E;YAC1E,IAAI,CAAC,KAAI,CAAC,KAAK,EAAE;gBACb,OAAO,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;gBAC9B,OAAO;aACV;YAED,KAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;YACzB,OAAO,CAAC,WAAW,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,CAAC;YAEvC,IAAI,QAAQ,CAAC,gBAAgB,EAAE;gBAC3B,QAAQ,CAAC,gBAAgB,EAAE,CAAC;aAC/B;YAED,IAAI,KAAI,CAAC,SAAS,EAAE;gBAChB,QAAQ,CAAC,OAAO,CAAC,KAAI,CAAC,SAAS,CAAC,CAAC;aACpC;QACL,CAAC,CAAC,CAAC;IACP,CAAC;IAEM,iCAAO,GAAd;QACI,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IAC5D,CAAC;IAEM,iCAAO,GAAd;QACI,OAAO,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC;IACpE,CAAC;IAEM,iCAAO,GAAd,UAAe,KAAW;QACtB,IAAI,IAAI,CAAC,QAAQ,EAAE;YACf,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;SAChC;aAAM;YACH,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;SAC1B;IACL,CAAC;IAEM,6CAAmB,GAA1B,UAA2B,WAAmB;QAC1C,IAAI,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,CAAC,mBAAmB,EAAE;YACpD,IAAI,CAAC,QAAQ,CAAC,mBAAmB,CAAC,WAAW,CAAC,CAAC;SAClD;IACL,CAAC;IACL,sBAAC;AAAD,CApDA,AAoDC,IAAA;AApDY,0CAAe","file":"dateCompWrapper.js","sourcesContent":["// removes the complexity of async component creation from the date panel. while the component does not\n// exist, the wrapper keeps the value that was set and returns this value when queried. when the component\n// is finally created, it gets the temp value if set.\nimport { IDateComp, IDateParams } from \"../../../rendering/dateComponent\";\nimport { UserComponentFactory } from \"../../../components/framework/userComponentFactory\";\nimport { Context } from \"../../../context/context\";\n\n/** Provides sync access to async component. Date component can be lazy created - this class encapsulates\n * this by keeping value locally until DateComp has loaded, then passing DateComp the value. */\nexport class DateCompWrapper {\n\n    private dateComp: IDateComp;\n    private tempValue: Date;\n    private alive = true;\n    private context: Context;\n\n    constructor(context: Context, userComponentFactory: UserComponentFactory, dateComponentParams: IDateParams, eParent: HTMLElement) {\n        this.context = context;\n\n        userComponentFactory.newDateComponent(dateComponentParams).then(dateComp => {\n            // because async, check the filter still exists after component comes back\n            if (!this.alive) {\n                context.destroyBean(dateComp);\n                return;\n            }\n\n            this.dateComp = dateComp;\n            eParent.appendChild(dateComp.getGui());\n\n            if (dateComp.afterGuiAttached) {\n                dateComp.afterGuiAttached();\n            }\n\n            if (this.tempValue) {\n                dateComp.setDate(this.tempValue);\n            }\n        });\n    }\n\n    public destroy(): void {\n        this.alive = false;\n        this.dateComp = this.context.destroyBean(this.dateComp);\n    }\n\n    public getDate(): Date {\n        return this.dateComp ? this.dateComp.getDate() : this.tempValue;\n    }\n\n    public setDate(value: Date): void {\n        if (this.dateComp) {\n            this.dateComp.setDate(value);\n        } else {\n            this.tempValue = value;\n        }\n    }\n\n    public setInputPlaceholder(placeholder: string): void {\n        if (this.dateComp && this.dateComp.setInputPlaceholder) {\n            this.dateComp.setInputPlaceholder(placeholder);\n        }\n    }\n}\n"]}