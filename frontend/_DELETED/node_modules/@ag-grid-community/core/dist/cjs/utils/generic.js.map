{"version":3,"sources":["../../src/ts/utils/generic.ts"],"names":[],"mappings":"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","file":"generic.js","sourcesContent":["/**\n * If value is undefined, null or blank, returns null, otherwise returns the value\n * @param {T} value\n * @returns {T | null}\n */\nexport function makeNull<T>(value?: T): T | null {\n    return value == null || value as any === '' ? null : value;\n}\n\nexport function exists<T>(value: T, allowEmptyString = false): boolean {\n    return value != null && (allowEmptyString || value as any !== '');\n}\n\nexport function missing<T>(value: T): boolean {\n    return !exists(value);\n}\n\nexport function missingOrEmpty<T>(value?: T[] | string): boolean {\n    return !value || missing(value) || value.length === 0;\n}\n\nexport function toStringOrNull(value: any): string | null {\n    return exists(value) && value.toString ? value.toString() : null;\n}\n\n/** @deprecated */\nexport function referenceCompare<T>(left: T, right: T): boolean {\n    if (left == null && right == null) {\n        return true;\n    }\n\n    if (left == null && right != null) {\n        return false;\n    }\n\n    if (left != null && right == null) {\n        return false;\n    }\n\n    return left === right;\n}\n\nexport function jsonEquals<T1, T2>(val1: T1, val2: T2): boolean {\n    const val1Json = val1 ? JSON.stringify(val1) : null;\n    const val2Json = val2 ? JSON.stringify(val2) : null;\n\n    return val1Json === val2Json;\n}\n\nexport function defaultComparator(valueA: any, valueB: any, accentedCompare: boolean = false): number {\n    const valueAMissing = valueA == null;\n    const valueBMissing = valueB == null;\n\n    // this is for aggregations sum and avg, where the result can be a number that is wrapped.\n    // if we didn't do this, then the toString() value would be used, which would result in\n    // the strings getting used instead of the numbers.\n    if (valueA && valueA.toNumber) {\n        valueA = valueA.toNumber();\n    }\n\n    if (valueB && valueB.toNumber) {\n        valueB = valueB.toNumber();\n    }\n\n    if (valueAMissing && valueBMissing) {\n        return 0;\n    }\n\n    if (valueAMissing) {\n        return -1;\n    }\n\n    if (valueBMissing) {\n        return 1;\n    }\n\n    function doQuickCompare<T>(a: T, b: T): number {\n        return (a > b ? 1 : (a < b ? -1 : 0));\n    }\n\n    if (typeof valueA === 'string') {\n        if (!accentedCompare) {\n            return doQuickCompare(valueA, valueB);\n        }\n\n        try {\n            // using local compare also allows chinese comparisons\n            return valueA.localeCompare(valueB);\n        } catch (e) {\n            // if something wrong with localeCompare, eg not supported\n            // by browser, then just continue with the quick one\n            return doQuickCompare(valueA, valueB);\n        }\n    }\n\n    return doQuickCompare(valueA, valueB);\n}\n\nexport function find<T>(collection: T[] | { [id: string]: T; }, predicate: string | boolean | ((item: T) => boolean), value?: any): T | null {\n    if (collection === null || collection === undefined) { return null; }\n\n    if (!Array.isArray(collection)) {\n        const objToArray = values(collection);\n        return find(objToArray, predicate, value);\n    }\n\n    const collectionAsArray = collection as T[];\n\n    let firstMatchingItem: T | null = null;\n    for (let i = 0; i < collectionAsArray.length; i++) {\n        const item: T = collectionAsArray[i];\n\n        if (typeof predicate === 'string') {\n            if ((item as any)[predicate] === value) {\n                firstMatchingItem = item;\n                break;\n            }\n        } else {\n            const callback = predicate as (item: T) => boolean;\n            if (callback(item)) {\n                firstMatchingItem = item;\n                break;\n            }\n        }\n    }\n\n    return firstMatchingItem;\n}\n\nexport function values<T>(object: { [key: string]: T; } | Set<T> | Map<any, T>): T[] {\n    if (object instanceof Set || object instanceof Map) {\n        const values: T[] = [];\n\n        object.forEach((value: T) => values.push(value));\n\n        return values;\n    }\n\n    return Object.keys(object).map(key => object[key]);\n}\n"]}